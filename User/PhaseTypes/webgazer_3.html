<!--
    This is based on code from the OSF repository <a href="https://osf.io/jmz79/" target="_blank">https://osf.io/jmz79/</a> which accompanies the publication "Online webcam-based eye tracking in cognitive science: a first look" by Semmelmann & Weigelt, published in Behavior Research Methods in 2017. Please find the abstract and information about the code, analyses, and data below. This work is intended for scientific use only.
Written by Kilian Semmelmann, tolcam@ksemmelm.de, 2017. <br><br>

Updates by Anthony Haffey (a.haffey@reading.ac.uk) 2020-21 to make this a task that works on Collector.
-->

<!DOCTYPE html>
<html>
<head>
  <link   href="libraries/webgazer/css/jquery-ui.css" type="text/css" rel="stylesheet">
  <link   href="libraries/webgazer/css/jquery.mobile-1.4.5.css" type="text/css" rel="stylesheet">
  <link   href="libraries/webgazer/css/tolcam.css" type="text/css" rel="stylesheet">
  <script src="libraries/webgazer/js/jquery-1.12.3.min.js"></script>
  <script src="libraries/webgazer/js/jquery-ui.js"></script>
  <script src="libraries/webgazer/js/jquery.mobile-1.4.2.min.js"></script>
  <script src="libraries/webgazer/js/simpleheat.js"></script>
</head>
<style>
.stimuli_img, .stimuli_video{
  object-fit: fill;
  margin:auto;
  top:0;
  bottom:0;
  vertical-align: middle;
  position: absolute;
  transform: translate(-50%, 0);
  left: 50%;
  background-repeat: no-repeat;
  background-size: contain;
}

#stimuli_fixation{
  position: absolute;
  top: 50%;
  left: 50%;
  -moz-transform: translateX(-50%) translateY(-50%);
  -webkit-transform: translateX(-50%) translateY(-50%);
  transform: translateX(-50%) translateY(-50%);
  font-size:100px;
  text-align:center;
  height:150px;
}
</style>
<body>
  <div id="instruction">
    <div id="instruction_1" class="instruction_page">
      Thank you for participating in this project. You will need to use your camera for eye-tracking to work in this experiment.
    </div>

    <div id="instruction_2" class="instruction_page">
      <h1>Webcam Setup</h1>
      <br />
      <div id="setup_after">
          You can take a short break and move your head. Before continuing, please follow the instructions noted below.<br />
      </div>
      <br />
      Please turn off your mobile phone and close all other programs and websites. Then carefully read and follow these instructions:<br />
      <img src="libraries/webgazer/imgs/instructions_donttilt.png" style = "width: 100%; margin-top: 20px; margin-bottom: 20px;"/> <br>
      If possible, please adjust your position until your face matches the picture below as much as possible:<br />
      <br />
      <table>
        <tr>
          <td>
            <img style="height:300px;width:400px; -webkit-transform: scaleX(-1); transform:scaleX(-1);" src="libraries/webgazer/imgs/ideal_pose.png"/>
          </td>
          <td>
            <span id="webcam_insert"></span>
          </td>
        </tr>
      </table>
      <br />
      <div id="setup_first">
          This study consists of multiple five-minute parts with pauses inbetween. After you clicked "start", please avoid moving your head. If you move too much, the calibration can fail and you might not be able to finish the Project.
      </div>
      <br />
    </div>

    <div id="instruction_3" class="instruction_page">
      <div id="beforetherest">
        <h1>Proceed</h1>
        <br />
        Click "Proceed" to move onto the next trial
        <button onclick="Phase.submit()" class="btn">Proceed</button>
      </div>
    </div>

    <div id="instruction_back" class="instruction_navigation">
      <div id="instruction_back_text">
        &lt;
      </div>
    </div>
    <div id="instruction_continue" class="instruction_navigation">
      <div id="instruction_continue_text">
        &gt;
      </div>
    </div>
  </div>

  <div id="calibration_dot" class="stimuli">
    <div id="calibration_cnt">0</div>
  </div>
  <div id="stimulus" class="stimuli">
    <img src="libraries/webgazer/imgs/talking.jpg" />
  </div>
  <div id="stimuli_div"></div>
  <div id="stimuli_dot" class="stimuli"></div>
  <div id="stimuli_bar" class="stimuli"></div>
  <div id="stimuli_fixation" class="stimuli">+</div>
  <div id="stimuli_prime" class="stimuli"></div>
  <div id="stimuli_target" class="stimuli">X</div>
  <div id="instruction_message"></div>

  <div id="message">
    no message
  </div>
 
  <!-- data quality info -->
  <input type="hidden" name="window_inner_height" id="window_inner_height"/>
  <input type="hidden" name="window_inner_width"  id="window_inner_width"/>
  <input type="hidden" name="fixation_rts"        id="fixation_rts"/>
  <input type="hidden" name="window_switches"     id="window_switches"/>
</body>
</html>
<script src="libraries/webgazer/framerate.js"></script>



<script>

/*
 * Collector needs to:
 - identify and store the video length
 - store the video start time
 - store the video end time
 */


window.addEventListener('blur', function(){ 
  var focus_val = $('#window_switches').val();
  $('#window_switches').val(focus_val + 'leave-' + (new Date()).getTime() + ';');
}); 

window.addEventListener('focus', function(){ 
  var focus_val = $('#window_switches').val();
  $('#window_switches').val(focus_val + 'focus-' + (new Date()).getTime() + ';')
});



/*
* Haffey variables
*/

var all_fixation_rts = [];

var image_pair;
Phase.set_timer(function(){
  function refuse_height(){
    bootbox.confirm("Your window height needs to be at least {{min_height}} before starting. Please make your window as big as possible before proceeding.", function(result){
      if(window.innerHeight < parseFloat("{{min_height}}".replace("px",""))){
        refuse_height();
      } else {
        $("#window_inner_height").val(window.innerHeight);
        $("#window_inner_width").val(window.innerWidth);
      }
    });
  };
  function refuse_width(){
    bootbox.confirm("Your window width needs to be at least {{min_width}} before starting. Please make your window as big as possible before proceeding.", function(result){
      if(window.innerWidth < parseFloat("{{min_width}}".replace("px",""))){
        refuse_width();
      } else {
        $("#window_inner_height").val(window.innerHeight);
        $("#window_inner_width").val(window.innerWidth);
      }
    });
  }
  if(window.innerHeight < parseFloat("{{min_height}}".replace("px",""))){
    refuse_height();
  } else {
        $("#window_inner_height").val(window.innerHeight);
        $("#window_inner_width").val(window.innerWidth);
      }
  if(window.innerWidth <  parseFloat("{{min_width}}".replace("px",""))){
    refuse_width();
  } else {
    $("#window_inner_height").val(window.innerHeight);
    $("#window_inner_width").val(window.innerWidth);
  }
},0);


/*
* default settings
*/

var calibrations     = "{{calibrations}}";
var image_file       = "{{image_file}}";
var design_type      = "{{design_type}}";
var calibration_skip = "{{calibration_skip}}";
var image_height     = "{{image_height}}";
var image_width      = "{{image_width}}";
var left_side        = "{{left_side}}";
var stim_duration    = "{{stim_duration}}";
var trials           = "{{trials}}";
var trial_order      = "{{trial_order}}";

var save_scripts = Object.keys(parent.parent.project_json.storage_scripts).map(function(server){
  return parent.parent.project_json.storage_scripts[server];
});


/*
* work out the location of the images
*/

if(calibrations.indexOf("calibrations") !== -1){
  calibrations = 13;
}
if(calibration_skip.indexOf("calibration_skip") !== -1){
  calibration_skip = "no";
}
console.log(stim_duration);
if(stim_duration < 1){
  stim_duration = 2000;
}
if(left_side.indexOf("left_side") !== -1){
  left_side = "counterbalance";  
}




/************************************
 * HELPER FUNCTIONS
 ************************************/
/**
 * Shuffles array in place.
 * @param {Array} a items The array containing the items.
 * @author http://stackoverflow.com/a/2450976/4175553
 */
function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}

/************************************
 * WEBCAM PARAMETERS
 ************************************/
var cam = {};
cam.overlay = '';
cam.width = 400;
cam.height = 300;
cam.topDist = '0px';
cam.leftDist = '0px';
cam.recording = 0;
cam.validating = 0;
cam.calibrating = 0;
cam.initialized = 0;

/************************************
 * CALIBRATION PARAMETERS
 ************************************/
var calibrating = 0;
var t_calibration_start;
var calibration_no = 0;
var calibration = {};
calibration.points = [];
calibration.method = "watch"; // click or watch
calibration.calibrations = calibrations // how many calibration dots
calibration.duration = 20; // how often does one position get sampled
calibration.instruction = 'Please look at each dot until <br /> it disappears. <br /><br />Please do not move your head,<br />only move your eyes.';
if("{{skip_instruct}}" == "on"){
  calibration.instruction_duration = 0;
} else {
  calibration.instruction_duration = 10000;
}

/************************************
 * VALIDATION PARAMETERS
 ************************************/
var validating = 0;
var validation_no = 0;
var validation_current = {"x": 0, "y": 0};
var validation_attempt = 1;
var validation = {};
validation.validations = 5;
validation.duration = 20;
validation.points = [];
validation.timeout = 20000; // if no validation happens within X ms, validation will be ended and re-calibrated
validation.attempts = 5; // how often can validation be failed PER validation
validation.distance = 200; // offset distance in pixel to be a valid validation sample


/************************************
* STARTING PARAMETERS
*************************************/
var stimuli_no = 0;

/************************************
 * DESIGN
 ************************************/
var design = {};
var block_no = 0;
var trial_no = 0;

eyetrack_designs = {
  stimuli: {
    'type': 'stimuli',
    'trials': trials,
    'iti': 500,
    'instruction': '{{text}}',
    'instruction_duration': 10000
  },
  simple: {
    'type': 'simple',
    'trials': 24,
    'iti': 500,
    'instruction': 'Please look at the cross.<br />When the dot appears, please look at it.<br /><br /><br />Do not move your head, <br />only use your eyes.',
    'instruction_duration': 5000
  },
  pursuit: {
    'type': 'pursuit',
    'trials': 24,
    'iti': 500,
    'instruction': 'A black dot will appear. Please <br />look at it. When it turns <span style="color: #dd494b;">red</span>,<br /> Please follow its movement with your eyes.<br /><br />Do not move your head, <br />only use your eyes.',
    'instruction_duration': 7000
  }
}

if("{{skip_instruct}}" == "on"){
  eyetrack_designs.stimuli.instruction_duration = 0;
}


design.blocks = [
  eyetrack_designs[["{{design_type}}"]]
];

//design.blocks = shuffle(design.blocks);
design.blocks_randomized = 1; // shall the blocks be shuffled?
design.trials_randomized = 1; // same for trials
design.calibrate = "high";
design.recalibrate = 1;



/************************************
 * DATA VARIABLES
 ************************************/
var data = [];
var data_current = {};
var status = '-';

/**
data.design = jQuery.extend(true, {}, design);
 **/

/************************************
 * SET UP WEBGAZER
 ************************************/
function loadWebgazer() {
  $('canvas').remove();
  cam.initialized = 0;
  $.getScript( "libraries/webgazer/js/webgazer_old.js" )
    .done(function( script, textStatus ) {
      initializeWebgazer();
      $('#message').html('Please allow for access on your Webcam on the top part of the screen. <br /><br />Remember: We will NOT transmit your video, but only process it locally and transmit numbers to our server.').show();
    })
    .fail(function( jqxhr, settings, exception ) {
      $( "div.log" ).text( "Triggered ajaxError handler." );
    });
}


function initializeWebgazer() {
 
  //webgazer.clearData()
  webgazer.setRegression('ridge') /* currently must set regression and tracker */
    .setTracker('clmtrackr')
    .setGazeListener(function(d, clock) {
      //console.log(data); /* data is an object containing an x and y key which are the x and y prediction coordinates (no bounds limiting) */
      //console.log(clock); /* elapsed time in milliseconds since webgazer.begin() was called */
      if (d !== null) {

        if (cam.calibrating == 1) {
            var $cd = $('#calibration_dot');
            var cx = parseInt(Math.round($cd.offset().left));
            var cy = parseInt(Math.round($cd.offset().top));
            var cp = d;
            var dist = Math.sqrt(((cp.x - cx) * (cp.x - cx)) + ((cp.y - cy) * (cp.y - cy)));
            var c = $('#calibration_cnt').html();
            data_current.raw.push({'time': clock, 'date_time': (new Date()).getTime(), 'x': cp.x, 'y': cp.y, 'cx': cx, 'cy': cy, 'dist': dist, 'c': c});
        }


        if (cam.validating == 1) {
            // see whether dx and dy are within 100px radius of target
            var dist = parseInt(Math.sqrt(((d.x - validation_current.x) * (d.x - validation_current.x)) + ((d.y - validation_current.y) * (d.y - validation_current.y))));
            var c = parseInt($('#calibration_cnt').html());
            if (dist < validation.distance) {
                data_current.raw.push({'time': clock, 'date_time': (new Date()).getTime(), 'x': d.x, 'y': d.y, 'vx': validation_current.x, 'vy': validation_current.y, 'dist': dist, 'c': c, 'valid': 1});
                if (c < calibration.duration) {
                    $('#calibration_cnt').html(++c);
                } else {
                    cam.validating = 0;
                    clearTimeout(t);
                    $('#calibration_dot').hide();
                    validation_no++;
                    saveData();
                    setTimeout("validate();", 500);
                }
            } else {
                data_current.raw.push({'time': clock, 'date_time': (new Date()).getTime(), 'x': d.x, 'y': d.y, 'vx': validation_current.x, 'vy': validation_current.y, 'dist': dist, 'c': c, 'valid': 0});
            }
        }

        if (cam.recording == 1) {
          
          var tx = -1;
          var ty = -1;
          if (data_current.task == "simple" || data_current.task == "pursuit") {
              var $sd = $('#stimuli_dot');
              var tx = parseInt(Math.round($sd.offset().left));
              var ty = parseInt(Math.round($sd.offset().top));
          }
          var this_row = {'time': clock, 'date_time': (new Date()).getTime(), 'x': d.x, 'y': d.y, 'tx': tx, 'ty': ty, 'status': status}
          //console.log(data.trials[trial_no].raw.length + ' ' + d.x + ' ' + d.y);
          /*
          * Store all the video frames
          */
          $(".stimuli_video").each(function(this_video){
            console.log(this_video);
            var this_id = $(".stimuli_video")[this_video].id;
            this_row[this_id + "_frame"] = active_videos[this_id].currentFrame;
          });
          data_current.raw.push(this_row);
        }
      }
    })
    .begin()
    .showPredictionPoints(false); /* shows a square every 100 milliseconds where current prediction is */

  cl = webgazer.getTracker().clm;

  checkWebgazer();
}


function checkWebgazer() {
  if (webgazer.isReady()) {
    console.log('webgazer is ready.');
    initializeCam();
  } else {
    setTimeout(checkWebgazer, 100);
  }
}

/************************************
 * SET UP WEBCAM
 ************************************/
function initializeCam() {
  var video = document.getElementById('webgazerVideoFeed');
  video.style.display = 'block'; // block
  video.style.position = 'relative';
  video.width = cam.width;
  video.height = cam.height;
  video.style.margin = '0px';
  $('#webgazerVideoFeed').css({
    'left': '50%',
    '-webkit-transform': 'scaleX(-1)',
    'transform': 'scaleX(-1) translate(50%, 0)',
    'margin': '20px'
  }).detach().insertAfter('#webcam_insert').get(0).play();
 
  webgazer.params.imgWidth = cam.width;
  webgazer.params.imgHeight = cam.height;

  cam.overlay = document.getElementById('overlay');
  if (cam.overlay === null) {
      cam.overlay = document.createElement('canvas');
      cam.overlay.id = 'overlay';
      document.body.appendChild(cam.overlay);
  }
  cam.overlay.style.position = 'absolute';
  cam.overlay.width = cam.width;
  cam.overlay.height = cam.height;
  cam.overlay.style.top = cam.topDist;
  cam.overlay.style.left = cam.leftDist;
  cam.overlay.style.margin = '0px';

  cam.initialized = 1;

  $('#message').html('Webcam access successful.').delay(1000).fadeOut(1000);
  $("#instruction_continue").show();
  parent.parent.requestFullScreen(parent.parent.document.documentElement);
}

/************************************
 * START BLOCKS
 ************************************/
function prepareBlock() {
  if (cam.initialized == 1) {
    if (block_no < design.blocks.length) {
      trial_no = 0;

      webgazer.resume();
      if (design.recalibrate == 1 || block_no == 0) {
        $('#instruction_message').html(calibration.instruction).show();
        setTimeout("$('#instruction_message').fadeOut(1000);", calibration.instruction_duration);
        setTimeout("startCalibration();", design.blocks[block_no].instruction_duration + 2000);
      } else {
        $('#instruction_message').html(design.blocks[block_no].instruction).show();
        setTimeout("$('#instruction_message').fadeOut(1000);", design.blocks[block_no].instruction_duration);
        setTimeout("prepareTrial();", design.blocks[block_no].instruction_duration + 2000);
      }
    } else {
      endExperiment();
    }
  } else {
    setTimeout("prepareBlock();", 500);
  }
}


/************************************
 * CALIBRATE
 ************************************/
function startCalibration() {
  if(calibration_skip == "skip" ||
     calibration_skip == "on"  ||
     calibration_skip == "yes" ||
     calibration_skip == "true"){
    endValidation()
  } else {
    $('.stimuli').hide();
    $('#calibration_dot').hide();
    if (block_no == 0) {
        $('#calibration_dot').click(function() {
            calibrateHit();
        });
    }
    calibration_no = 0;
    //webgazer.clearData();
    window.localStorage.clear();
    //webgazer.begin();
    t_calibration_start = new Date().getTime();
    calibrate();
  }
}

var gaze_phase = "unknown";

function calibrate() {
  gaze_phase = "calibrate";
  clearTimeout(t);
  if (calibration_no < calibration.calibrations) {
    $('#calibration_cnt').html(calibration.duration);
    $c = $('#calibration_dot');
    //var c = Math.floor(Math.random() * calibration.points.length);
    //var p = calibration.points.splice(c, 1)[0];
    if (calibration.points.length == 0) {
     
      /*
      * allocate calibration by pixels rather than percentages
      */
     
      var min_width   = "{{min_width}}".replace("px","");                          // e.g. 1000px in Borcsok et al., (2020)
      var min_height   = "{{min_height}}".replace("px","");                         // e.g. 400px  in Borcsok et al., (2020)
      var mid_screen_x = window.innerWidth / 2;
      var mid_screen_y = window.innerHeight / 2;
     
      calibration.points = shuffle([
       
        {
          position: "middle",
          x: mid_screen_x,
          y: mid_screen_y
        },
        {
          position: "top",
          x: mid_screen_x,
          y: mid_screen_y - min_height/2 * .9
        },
        {
          position: "bottom",
          x: mid_screen_x,
          y: mid_screen_y + min_height/2 * .9
        },
        {
          position: "left",
          x: mid_screen_x - min_width/2 * .9,
          y: mid_screen_y
        },
        {
          position: "right",
          x: mid_screen_x + min_width/2 * .9,
          y: mid_screen_y
        },
        {
          position: "outer-top-left",
          x: mid_screen_x - min_width/2  * .9,
          y: mid_screen_y - min_height/2 * .9
        },
        {
          position: "outer-top-right",
          x: mid_screen_x + min_width/2  * .9,
          y: mid_screen_y - min_height/2 * .9
        },
        {
          position: "outer-bottom-left",
          x: mid_screen_x - min_width/2  * .9,
          y: mid_screen_y + min_height/2 * .9
        },
        {
          position: "outer-bottom-right",
          x: mid_screen_x + min_width/2  * .9,
          y: mid_screen_y + min_height/2 * .9
        },
        {
          position: "inner-top-left",
          x: mid_screen_x - min_width/2  * .45,
          y: mid_screen_y - min_height/2 * .45
        },
        {
          position: "inner-top-right",
          x: mid_screen_x + min_width/2  * .45,
          y: mid_screen_y - min_height/2 * .45
        },
        {
          position: "inner-bottom-left",
          x: mid_screen_x - min_width/2  * .45,
          y: mid_screen_y + min_height/2 * .45
        },
        {
          position: "inner-bottom-right",
          x: mid_screen_x + min_width/2  * .45,
          y: mid_screen_y + min_height/2 * .45
        }
      ]);
     
    }
    var p = calibration.points.pop();
    $c.css({
        'left' : p.x,
        'top' : p.y
    });

    data_current = {
        'type': 'calibration',
        'block': block_no,
        'trial': calibration_no,
        'x': p.x,
        'y': p.y,
        'raw': []
    };

    cam.calibrating = 1;
    $c.show();
    if (calibration.method == 'watch') {
      t = setTimeout("autoCalibration();", 750);
    }
  } else {
    endCalibration();
  }
}

function calibrateHit() {
  var c = $('#calibration_cnt').html();
  /*
  if ($('#webgazerVideoFeed').css('display') == 'block') {
      $('#webgazerVideoFeed').css({
          top: cam.topDist,
          left: cam.leftDist,
          display: 'none',
          transform: '0'
      });
  }*/
  if (c > 1 && cam.calibrating == 1) {
    $('#calibration_cnt').html(--c);
    if (calibration.method == "watch") {
      t = setTimeout("autoCalibration();", 100);
      //requestAnimationFrame(autoCalibration);
    }
  } else {
    $('#calibration_cnt').html(9999);
    clearTimeout(t);
    cam.calibrating = 0;
    $('#calibration_dot').hide();
    calibration_no++;
    saveData();
    calibrate();
  }
  return false;
}

var t;
function autoCalibration() {
  calibrateLog();
  if (cam.calibrating == 1) {
    calibrateHit();
  }
}

function calibrateLog() {
  var $cd = $('#calibration_dot');
  var cx = parseInt(Math.round($cd.offset().left));
  var cy = parseInt(Math.round($cd.offset().top));
  webgazer.watchListener(cx, cy);
}


function endCalibration() {
  clearTimeout(t);
  $('#calibration_dot').unbind("click");
  startValidation();
}



/************************************
 * VALIDATE
 ************************************/
function startValidation() {
  validation_no = 0;
  validate();
}

function validate() {
  gaze_phase = "validate";
  clearTimeout(t);
  if (validation_no < validation.validations) { // if we there are validations left
    $('#calibration_cnt').html(0);
    var $c = $('#calibration_dot');
   
    if (validation.points.length == 0) {
   
      /*
      * allocate positions by pixels rather than percentages
      */
     
      var min_width   = "{{min_width}}".replace("px","");                          // e.g. 1000px in Borcsok et al., (2020)
      var min_height   = "{{min_height}}".replace("px","");                         // e.g. 400px  in Borcsok et al., (2020)
      var mid_screen_x = window.innerWidth / 2;
      var mid_screen_y = window.innerHeight / 2;
     
      validation.points = shuffle([
        {
          position: "top-left",
          x: mid_screen_x - min_width/2  * .9,
          y: mid_screen_y - min_height/2 * .9
        },
        {
          position: "top-right",
          x: mid_screen_x + min_width/2  * .9,
          y: mid_screen_y - min_height/2 * .9
        },
        {
          position: "middle",
          x: mid_screen_x,
          y: mid_screen_y
        },
        {
          position: "bottom-left",
          x: mid_screen_x - min_width/2  * .9,
          y: mid_screen_y + min_height/2 * .9
        },
        {
          position: "bottom-right",
          x: mid_screen_x + min_width/2  * .9,
          y: mid_screen_y + min_height/2 * .9
        },
      ]);
    }
    var vp = validation.points.pop();
    $c.css({
        'left' : vp.x,
        'top' : vp.y
    });
    $c.show();
    validation_current.x = Math.round($c.offset().left);
    validation_current.y = Math.round($c.offset().top);

    data_current = {
      'type': 'validation',
      'block': block_no,
      'trial': validation_no,
      'x': validation_current.x,
      'y': validation_current.y,
      'raw': []
    };
    cam.validating = 1;
    t = setTimeout("validateFail();", validation.timeout);
    //t = setTimeout('validation = 0;', 3000);
  } else {
    endValidation();
  }
}

function validateFail() {
  data_current.type = 'validationfail';
  data_current.attempt = validation_attempt;
  saveData();


  cam.validating = 0;
  webgazer.pause();

  $('.stimuli').hide();
  if (validation_attempt >= validation.attempts) {
      $('#message').html('Unforuntately, the calibration failed too many times. Therefore, you can not participate in this Project. Please contact <a href="mailto:kilian.semmelmann@rub.de">kilian.semmelmann@rub.de</a> if you have any questions. Thanks for your interest.').show();
  } else {
      validation_attempt++;
      $('#message').html('The calibration failed. <br />Please follow the instructions and try again (try ' + (validation_attempt) + ' of ' + validation.attempts + ').').show().delay(5000).fadeOut(1000);
      $('#instruction').show();
  }
  // TOOD: log validation-fail
}

function endValidation() {
  cam.validating = 0
  validation_attempt = 1;
  webgazer.pause();
  $('#instruction_message').html(design.blocks[block_no].instruction).show();
  setTimeout("$('#instruction_message').fadeOut(1000);", design.blocks[block_no].instruction_duration);
  setTimeout("prepareTrial();", design.blocks[block_no].instruction_duration + 2000);
}



/************************************
 * START EXPERIMENT
 ************************************/
var t_trial_start;
function prepareTrial() {
  status = "prepare";
  $('.stimuli').hide();
  data_current = {
      'type': 'trial',
      'block': block_no,
      'trial': trial_no,
      'raw': []
  };
  webgazer.resume();
  startTrial();
}


function startTrial() {
  t_trial_start = new Date().getTime();
  $('#stimuli_fixation').show();
  status = "fixation_onset";
  // use start function of block-type name
  var fn = design.blocks[block_no].type+"Start";
  window[fn]();
}


var heat;
function endTrial() {
  $(window).unbind("keypress");
  $("#stimuli_div").html("");
  clearTimeout(t);
  cam.recording = 0;
  webgazer.pause();
  status = "end";
  $('.deletable').remove();
  trial_no++;
  saveData();

  if (trial_no < design.blocks[block_no].trials) {
    setTimeout("prepareTrial();", design.blocks[block_no].iti);
  } else {
    block_no++;
    if (block_no < design.blocks.length) {
      window.localStorage.clear();
      webgazer.clearData();
      //loadWebgazer();
      //prepareBlock();
      navigation('pause');
    } else {
      endExperiment();
    }
  }
}


function saveData() {
 
 
  /*
  * did the participant pass validation?
  */
  //data_current
 

  /*
  * change file name depending on whether it's calibration, validation or main trial?
  * add calibration / validation / freeview number
  */

  var sub_trial_no = -1;
  switch(gaze_phase){
    case "calibration":
      sub_trial_no = calibration_no;
      break;
    case "validate":
      sub_trial_no = validation_no;
     
      /*
      * did the participant pass? (assuming this is validation)
      */
      var valid_rows = 0;
     
      data_current.raw.forEach(function(row){
        valid_rows += row.valid;
      });
     
      break;
    case "stimuli":
      sub_trial_no = stimuli_no;
      break;
     
  }
 
 
 
  data_current.raw = data_current.raw.map(function(row){
    row.x = row.x - window.innerWidth/2;
    row.y = row.y - window.innerHeight/2;
   
    if(typeof(image_pair) !== "undefined"){
      Object.keys(image_pair).forEach(function(key){
        row[key] = image_pair[key];
      });
    }
    row.screen_width  = screen.width;
    row.screen_height = screen.height;
    row.window_width  = window.innerWidth;
    row.window_height = window.innerHeight;
    row.participant   = parent.parent.$("#participant_code").val(),
    row.trial_no      = sub_trial_no;
    
    /*
     * add video info if the video exists - this is to help with calculating which frame the participant was looking at
     */
    row.video_duration = video_duration;
    row.video_start_time = video_start_time;
    row.video_end_time = video_end_time;

    
    if(window.innerHeight == screen.height){
      row.fullscreen = true;
    } else {
      row.fullscreen = false;
    }

    //switching window...
    row.window_switches = $("#window_switches").val();
   
    if(typeof(stimuli_set) !== "undefined"){
      Object.keys(stimuli_set).forEach(function(stimuli_key){
        row[stimuli_key] = stimuli_set[stimuli_key];
      });
    }
   
   
    if(valid_rows > 19){
      row.valid_trial = true;
    } else {
      row.valid_trial = false;
    }
    return row;
  });
  
  video_duration = "tbc";
  video_start_time = "tbc";
  video_end_time = "tbc";

  $("#window_switches").val("");
 
  data.push(data_current);
  data_current = {};
  sendData();
}


function sendData() {

  var sub_trial_no = -1;
  switch(gaze_phase){
    case "calibration":
      sub_trial_no = calibration_no;
      break;
    case "validate":
      sub_trial_no = validation_no;
      break;
    case "freeview":
      sub_trial_no = stimuli_no;
      break;
  }
 
  switch(parent.parent.Project.get_vars.platform){
    case "preview":
      //do nothing
      break;
    case "localhost":
      data.forEach(function(trial,trial_no){
        if (trial !== null){
          parent.parent.Collector.electron.fs.write_data(
            parent.parent.Project.get_vars.location,
            parent.parent.$("#participant_code").val() + "-" +
              parent.parent.project_json.trial_no      + "-" +
              gaze_phase                               + "-" +
              trial_no                                 + "-" +
              sub_trial_no                             + ".csv",
            Papa.unparse(data[trial_no].raw)
          );
                                     
          /*                          
          parent.parent.online_save(parent.parent.Project.get_vars.location,
                    parent.parent.$("#participant_code").val() +
                      gaze_phase +
                      "-" +
                      trial_no +
                      "-" +
                      sub_trial_no,
                      "-trial-" +
                      parent.parent.project_json.trial_no +
                      "-" +
                      trial_no,
                    parent.parent.$("#completion_code").val(),
                    parent.parent.$("#prehashed_code").val(),  
                    Papa.unparse(data[trial_no].raw),          //the data
          save_scripts,
          function(){
            parent.parent.online_data_obj.saves_ended ++;
          });
          */
          data[trial_no] = null;
        }
      });
      break;
    default:
      data.forEach(function(trial,trial_no){
        if (trial !== null){
          var file_name = parent.parent.$("#participant_code").val() + "-" + gaze_phase + "-trial-" + parent.parent.project_json.trial_no + "-" + trial_no + "-" + sub_trial_no;
          parent.parent.online_save(
            parent.parent.Project.get_vars.location,
            file_name,
            parent.parent.$("#completion_code").val(),
            parent.parent.$("#prehashed_code").val(),
            Papa.unparse(data[trial_no].raw),
            /*
            JSON.stringify(
              parent.parent.encrypt(
                parent.parent.project_json.public_key,
                Papa.unparse(data[trial_no].raw)          //the data  
              )
            ),
            */
            parent.parent.project_json.storage_scripts,
            function(){
              parent.parent.online_data_obj.saves_ended ++;
            },
            "trial",
            file_name);
            data[trial_no] = null;
          }
      });
       
        break;
  }
}


function endExperiment() {
  Phase.submit();
}


/************************************
 * SIMPLE DOT VIEWING PARADIGM
 * If you want to introduce your own paradigms, follow the same structure and extend the design array above.
 ************************************/
var tSimple = {};
tSimple.positions = [];
function simpleStart() {
    // if we don't have dot-positions any more, refill the array
    if (tSimple.positions.length == 0) {
        tSimple.positions = shuffle([
            {x: "20%", y: "20%"},
            {x: "50%", y: "20%"},
            {x: "80%", y: "20%"},
            {x: "20%", y: "50%"},
            {x: "80%", y: "50%"},
            {x: "20%", y: "80%"},
            {x: "50%", y: "80%"},
            {x: "80%", y: "80%"}
        ]);
    }
    var pos = tSimple.positions.pop();
    $('#stimuli_dot').css({
        'top': pos.y,
        'left': pos.x
    });
    data_current.task = 'simple';
    data_current.x = pos.x;
    data_current.y = pos.y;
    data_current.condition = 'dot_' + pos.x + '_' + pos.y;

    cam.recording = 1;
    setTimeout('$("#stimuli_fixation").hide(); status = "fixation_offset";', 1500);
    setTimeout('simpleShowdot();', 2000);
}

function simpleShowdot() {
    status = "stimulus_onset";
    $("#stimuli_dot").show();
    setTimeout('status = "stimulus_offset"; endTrial();',  2000);
}


/************************************
 * POSNER VIEWING PARADIGM
 ************************************/
function posnerStart() {
    var p = Math.random() >= 0.5 ? '&gt;&gt;&gt;' : '&lt;&lt;&lt;';
    $('#stimuli_prime').html(p);

    var t = Math.random() >= 0.5 ? 'X' : 'N';
    $('#stimuli_target').html(t);

    var cond = Math.random() >= 0.7 ? 'incongruent' : 'congruent';

    var tpos = 'left';
    if ((cond == 'incongruent' && p == '&lt;&lt;&lt;') || ((cond == 'congruent' && p == '&gt;&gt;&gt;'))) {
        tpos = 'right';
    }

    var pos = {};
    if (tpos == 'left') {
        pos.x = '20%';
        pos.y = '30%';
    } else {
        pos.x = '80%';
        pos.y = '30%';
    }


    $('#stimuli_target').css({
      'top':  pos.x,
      'left': pos.y
    });


    data_current.task = 'posner';
    data_current.x = pos.x;
    data_current.y = pos.y;
    data_current.condition = 'posner_' + pos.x + '_' + pos.y + '_' + tpos;

    cam.recording = 1;
    setTimeout("$('#stimuli_fixation').hide();", 1000);
    setTimeout('posnerShowprime();', 1500);
}

function posnerShowprime() {
    $('#stimuli_prime').show();
    setTimeout("posnerShowTarget();", 300);
}

function posnerShowTarget() {
    $('#stimuli_prime').hide();
    $('#stimuli_target').show();
    setTimeout("endTrial();", 1500);
}


/************************************
 * SMOOTH PURSUIT PARADIGM
 ************************************/
var tPursuit = {};
function pursuitStart() {
  $('#stimuli_fixation').hide();
  var pos_possible = shuffle([
    {x: "20%", y: "20%", tx: "80%", ty: "20%"},
    {x: "20%", y: "20%", tx: "20%", ty: "80%"},
    {x: "20%", y: "20%", tx: "80%", ty: "80%"},

    {x: "80%", y: "20%", tx: "20%", ty: "20%"},
    {x: "80%", y: "20%", tx: "20%", ty: "80%"},
    {x: "80%", y: "20%", tx: "80%", ty: "80%"},

    {x: "20%", y: "80%", tx: "20%", ty: "20%"},
    {x: "20%", y: "80%", tx: "80%", ty: "20%"},
    {x: "20%", y: "80%", tx: "80%", ty: "80%"},

    {x: "80%", y: "80%", tx: "20%", ty: "20%"},
    {x: "80%", y: "80%", tx: "80%", ty: "20%"},
    {x: "80%", y: "80%", tx: "20%", ty: "80%"}
  ]);
  var pos = pos_possible[0];
  $s = $('#stimuli_dot');
  $s.css({
    'top': pos.y,
    'left': pos.x
  });

  $s.css({
    'background-color': '#000'
  });


  data_current.task = 'pursuit';
  data_current.x = pos.x;
  data_current.y = pos.y;
  data_current.condition = 'pursuit_' + pos.x + '_' + pos.y + '_' + pos.tx + '_' + pos.ty;

  cam.recording = 1;
  $s.show();
  setTimeout(function() {
    status = "pursuit_start";
    $('#stimuli_dot').css({
      'background-color': '#dd494b'
    }).animate({ "left": pos.tx, "top": pos.ty },
      2000,
      'linear',
    function() {
      status = "pursuit_end";
      setTimeout("endTrial();", 500);
    });
  }, 1500);
}



/************************************
 * STIMULI PARADIGM
 ************************************/
var tStimuli = {};


tStimuli.stimuli = [];

var video_start_time = "tbc";
var video_end_time = "tbc";
var video_duration = "tbc";

function process_stimuli(){
  if(trial_order == "random"){
    tStimuli.stimuli = shuffle(tStimuli.stimuli);
  }
 
 
  if(left_side == "random"){
    for(var i = 0; i < tStimuli.stimuli.length; i++){
      [left_image,right_image] = shuffle([tStimuli.stimuli[i].image_1,
                                          tStimuli.stimuli[i].image_2]);
      tStimuli.stimuli[i].image_1 = left_image;
      tStimuli.stimuli[i].image_2 = right_image;
    }
  } else if(left_side == "equal" | left_side == "counterbalance"){
    // select indexes to swap left and right for half the indexes
    // all indexes:
    var indexes = Array.from({length:tStimuli.stimuli.length},(v,k)=>k);
        indexes = shuffle(indexes);
   
    //assign the first half left to right
    for(var i = 0; i < Math.floor(tStimuli.stimuli.length / 2); i++){          //this will only loop through half of the randomised indexes
      var this_index = indexes[i];
      var right_image = tStimuli.stimuli[this_index].image_1;
      var left_image = tStimuli.stimuli[this_index].image_2;
      tStimuli.stimuli[this_index].image_1 = left_image;
      tStimuli.stimuli[this_index].image_2 = right_image;
    }
  } else if(left_side == "image_1"){
    // do nothing
  } else if(left_side == "image_2"){
    for(var i = 0; i < Math.floor(tStimuli.stimuli.length / 2); i++){
      var right_image = tStimuli.stimuli[i].image_1;
      var left_image = tStimuli.stimuli[i].image_2;
      tStimuli.stimuli[i].image_1 = left_image;
      tStimuli.stimuli[i].image_2 = right_image;
    }
  } else {
    //alert("there's a problem in the 'left_side' column - fix this before testing.");
  }
};



//check if the freeview file matches one of the stimuli files
if(typeof(parent.parent.project_json.all_stims[image_file]) !== "undefined"){
  var trial_contents = Papa.parse(parent.parent.project_json.all_stims[image_file]).data;
  var trial_clean    = trial_contents.map(function(row){
    return row.filter(item => item !== null);
  });
  tStimuli.stimuli = Papa.parse(Papa.unparse(trial_clean),{
    header:true,
    skipEmptyLines:true
  }).data;
  process_stimuli();
} else {
  if(image_file.toLowerCase().indexOf("https://") == -1){                //i.e. isn't stored on dropbox or some other remote location
    image_file = "../User/" + image_file;
  }
  $.get(image_file,function(result){
    tStimuli.stimuli = Papa.parse(result,{
      header:true,
      skipEmptyLines:true
    }).data;
    process_stimuli();
  });
}


stimuli_src_loaded = 0;
var stimuli_src_length;
var active_keys = {};

/*
* Some code to make this work on installed version of Collector
*/
switch(parent.parent.Project.get_vars.platform){
  case "preview":
  case "localhost":
    org_repo = parent.parent.project_json.location.split("/");
    home_dir = parent.parent.Collector.electron.git.locate_repo({
      org: org_repo[0],
      repo: org_repo[1]
    });
    break;
  default:
    home_dir = "../";
    break;
}

function check_end_trial(element_json){
  if(typeof(element_json.end_trial) !== "undefined" && element_json.end_trial.toLowerCase() == "yes"){
    status = 'stimulus_offset';
    endTrial();
  }
}

function stimuli_loaded(){
  stimuli_no++;
 
  data_current.task = 'stimuli';
 
  cam.recording = 1;
  status = 'fixation_flash_first_half';
  $('#stimuli_fixation').css("color","red");
  setTimeout(function(){
    $('#stimuli_fixation').css("color","black");
  }, 250);
  setTimeout(function(){
    $('#stimuli_fixation').css("color","red");
  }, 500);
  setTimeout(function(){
    $('#stimuli_fixation').css("color","black");
  }, 750);
  setTimeout(function(){
    status = 'fixation_flash_second_half';
    $('#stimuli_fixation').css("color","red");
  }, 1000);
  setTimeout(function(){
    $('#stimuli_fixation').css("color","black");
  }, 1250);
  setTimeout(function(){
    $('#stimuli_fixation').css("color","red");
  }, 1500);
  setTimeout(function(){
    $('#stimuli_fixation').css("color","black");
  }, 1750);
  setTimeout(function(){
    $('#stimuli_fixation').hide();
    status = 'fixation_offset';
  }, 2000);
 
 
  /*
  * set timers here
  */
 
  var these_elements = stimuli_set.elements.split(",");
 
 
  these_elements.forEach(function(this_element){
    var element_json = JSON.parse(stimuli_set[this_element]);
   
    /*
    * add other properties from other relevant columns
    */
    var other_properties = Object.keys(stimuli_set).filter(item => item.indexOf(this_element + ".") == 0);
   
    other_properties.forEach(function(item){
      element_json[item.split(".")[1]] = stimuli_set[item];
    });
   

    /*
    * deal with elements that are triggered by the end of audio or videos
    */
    if(typeof(element_json.onset) !== "number" && element_json.onset.indexOf(".ended") !== -1){
     
      trigger_element = element_json.onset.split(".")[0];
      //alert("trigger_element = " + trigger_element);
      
      
      
      $("#" + trigger_element).on("ended", function(){
        var baseline_time = (new Date()).getTime();
        //alert("this_element " + this_element);
        $("#" + this_element).show();
        status += "-" + this_element;
        
        
        
        /*
         * what does this play do? Is this correct
         */
        
        $("#" + this_element).trigger("play");
       
       
        if(element_json.type == "keys"){
          $(window).bind('keypress', function(event) {
            keyboard_response(element_json, event, baseline_time, this_element);
          });
        }
       
      });
    } else {
      setTimeout(function(){
        var baseline_time = (new Date()).getTime();
        status += "-" + this_element;
        if(element_json.type == "keys"){
          $(window).bind('keypress', function(event) {
            keyboard_response(element_json, event, baseline_time, this_element);
            /*
            if(element_json.keys.indexOf(String.fromCharCode(event.charCode)) !== -1){
              $("#" + this_element + "_value_" + trial_no).val(event.which);
              $("#" + this_element + "_value_rt_"  + trial_no).val((new Date()).getTime() - baseline_time);
              check_end_trial(element_json);
            }
            */
          });
        }
       
        $("#" + this_element).show();
        
        /*
         * Collector needs to:
         - identify and store the video length
         - store the video start time
         - store the video end time
         */
        video_start_time = (new Date()).getTime();
        $("#" + this_element).trigger("play");
        
        active_videos[this_element] = VideoFrame({
          id : this_element,
          //frameRate: 25,
          callback : function(frame) {
            console.log("frame = " + frame);
            active_videos[this_element].currentFrame = frame;
          }
        });
        active_videos[this_element].listen("frame");
       
      }, 2000 + element_json.onset);
    }

    if(element_json.duration == "end"){
      $("#" + this_element).on('ended', function(){
        
        /*
         * Collector needs to:
         - identify and store the video length
         - store the video start time
         - store the video end time
         */
        video_end_time = (new Date()).getTime();
        video_duration = $("#" + this_element)[0].duration;
        
        
        status = status.replace("-" + this_element,"");
        $("#" + this_element).hide();
        check_end_trial(element_json);
        active_videos[this_element].stopListen();
      });
    } else {
      setTimeout(function(){
        $("#" + this_element).hide();
        status = status.replace("-" + this_element,"");
        active_videos[this_element].stopListen();
        //check_end_trial(element_json);
      }, 2000 + element_json.onset + element_json.duration);

    }
  });
}

function keyboard_response(element_json, event, baseline_time, this_element){
  element_json.keys    = element_json.keys.split("|");
  element_json.answers = element_json.answers.split("|");
  if(element_json.keys.indexOf(String.fromCharCode(event.charCode)) !== -1){
    var key_response = String.fromCharCode(event.charCode);
    var key_answer   = element_json.answers[element_json.keys.indexOf(key_response)];
    $("#" + this_element + "_value_"  + trial_no).val(key_response);
    $("#" + this_element + "_answer_"  + trial_no).val(key_answer);
    $("#" + this_element + "_value_rt_"  + trial_no).val((new Date()).getTime() - baseline_time);
    check_end_trial(element_json);
  }
}

var stimuli_set;

function stimuliStart() {
  gaze_phase = "stimuli";
 
  document.body.style.cursor = 'none';
  stimuli_set = tStimuli.stimuli.shift();
 
  stimuli_src_loaded = 0;

 
  [audio_set, image_set, video_set, text_set] = Array(4).fill([]);
  var these_elements = stimuli_set.elements.split(",");
  these_elements.forEach(function(this_element){
    var element_json = JSON.parse(stimuli_set[this_element]);
   
    /*
    * add other properties from other relevant columns
    */
    var other_properties = Object.keys(stimuli_set).filter(item => item.indexOf(this_element + ".") == 0);
   
    other_properties.forEach(function(item){
      element_json[item.split(".")[1]] = stimuli_set[item];
    });
   
   
    switch(element_json.type){
     
      case "audio":
        var this_item = $("<audio>");
        this_item.prop("src", home_dir + element_json.src.replace("../User","/User"))
          .addClass("deletable")
          .prop("id", this_element);
        $("#stimuli_div").append(this_item);
        $("#" + this_element).on("canplay canplaythrough",function(){
          stimuli_src_loaded = stimuli_src_loaded + 1;
         
          if(these_elements.length == stimuli_src_loaded){
            stimuli_loaded();
          }
        });
        break;
      case "image":
        var this_item = $("<img>");
        this_item.prop("src", home_dir + element_json.src.replace("../User","/User"))
          .addClass("deletable")
          .addClass("stimuli")
          .addClass("stimuli_img")
          .css("margin-left",   element_json.x)
          .css("top",    element_json.y)
          .css("width",  element_json.width)
          .css("height", element_json.height)
          .css("display", "none")
          .prop("id", this_element);
        $("#stimuli_div").append(this_item);
        $("#" + this_element).on("load",function(){
         
          stimuli_src_loaded = stimuli_src_loaded + 1;
          if(these_elements.length == stimuli_src_length){
            stimuli_loaded();
          }
        });
        break;
      case "keys":
       
        var response_item = $("<input>");
        response_item.prop("id", this_element + "_value_"  + trial_no)
          .prop("name", this_element + "_value_" + trial_no)
          .css("display", "none");
         
        var rt_item = $("<input>");
        rt_item.prop("id", this_element + "_value_rt_"  + trial_no)
          .prop("name", this_element + "_value_rt_" + trial_no)
          .css("display", "none");
          
        var answer_item = $("<input>");
        answer_item.prop("id", this_element + "_answer_"  + trial_no)
          .prop("name", this_element + "_answer_" + trial_no)
          .css("display", "none");
       
        $("body").append(response_item);
        $("body").append(rt_item);
        $("body").append(answer_item);
       
       
        stimuli_src_loaded = stimuli_src_loaded + 1;
        if(these_elements.length == stimuli_src_loaded){
          stimuli_loaded();
        }
        break;
      case "text":
        //alert("hi");
        this_item = $("<div>");
        this_item.html(element_json.text)
          .addClass("stimuli")
          .addClass("deletable")
          .css("margin-left",   element_json.x)
          .css("top",    window.innerHeight/2 + element_json.y)
          .css("width",  element_json.width)
          .css("height", element_json.height)
          .css("display", "none")
          .prop("id", this_element);
        $("#stimuli_div").append(this_item);
        stimuli_src_loaded = stimuli_src_loaded + 1;
       
        if(these_elements.length == stimuli_src_loaded){
          stimuli_loaded();
        }
        break;
      case "video":
        var this_item = $("<video>");
        var this_source = $("<source>");
            this_source.prop("src", home_dir + element_json.src.replace("../User","/User"));
       
            this_item.prop("src", home_dir + element_json.src.replace("../User","/User"))
              .addClass("stimuli")
              .addClass("stimuli_video")
              .addClass("deletable")
              .css("margin-left",   element_json.x)
              .css("top",    element_json.y)
              .css("width",  element_json.width)
              .css("height", element_json.height)
              .css("display", "none")
              .prop("id", this_element);
        this_item.append(this_source);
        $("#stimuli_div").append(this_item);
        $("#" + this_element).on("loadstart",function(){
          stimuli_src_loaded = stimuli_src_loaded + 1;
         
          if(these_elements.length == stimuli_src_loaded){
            stimuli_loaded();
          }
        });
        
        /*
        * tracking frames
        */
        
        
        
        /*
        $('#play-pause').click(function(){
          if(video.video.paused){
            video.video.play();
            video.listen('frame');
            $(this).html('Pause');
          }else{
            video.video.pause();
            video.stopListen();
            $(this).html('Play');
          }
        });
        */
        
        
        
        
        break;
    }
   
    //if(typeof(stimuli_set[this_element + "."])
  });
}

active_videos = {};


/************************************
 * GENERATE AND SHOW HEATMAP
 ************************************/
function heatmap() {
    // preprocess data for heatmap
    var bins = []; // create bins and fill them
    for (var y = 0; y < window.innerHeight; y++) {
        for (var x = 0; x < window.innerWidth; x++) {
            bins.push([x, y, 0]);
        }
    }
    // sort fixations into bins and get max
    var max = 0;
    for (var i = 0; i < data[data.length - 1].raw.length; i++) {
        var d = data[data.length - 1].raw[i];
        var dx = Math.round(d.x);
        var dy = Math.round(d.y);
        var pos = (dy * window.innerWidth) + dx;
        if (pos <= bins.length && pos >= 0) {
            bins[pos][2] += 1;
            if (bins[pos][2] > max) {
                max = bins[pos][2];
            }
        } else {
            console.log('dropped ' + pos);
        }
    }

    // remove empty bins
    var binsc = [];
    for (var i = 0; i < bins.length; i++) {
        if (bins[i][2] != 0) {
            binsc.push(bins[i]);
        }
    }

    // create heatmap
    $('body').append("<canvas id=\"heatmap\"></canvas>");
    $('#heatmap').attr('width', window.innerWidth);
    $('#heatmap').attr('height', window.innerHeight);
    heat = simpleheat('heatmap');
    heat.resize();
    heat.radius(30,50);
    heat.max(max).data(binsc).draw();

    $('#stimuli_img').show();
}


/**
 * navigation
 */
var page = 1;
var oldpage = -1;
var d_consent = undefined;
function navigation(direction) {
  $('#message').hide();

  $('#instruction_continue_text').html("&gt;");


 
if (page == 2 && direction == 'continue') {
    if (cam.initialized == 1) {
      $('#instruction').fadeOut(1000);
      setTimeout("prepareBlock();", 2000);
    }
  } else if (page == 2 && direction == 'pause') {
    $('#instruction_continue').html("continue").css({'font-size': '1.7em'});
    $('#instruction_2').find("h1").html('short pause (block ' + block_no + ' of ' + design.blocks.length + ")");
    $('#setup_first').hide();
    $('#setup_after').show();

    $('#instruction').show(function() {
      if (block_no == design.blocks.length) {
        page++;
      } else {
        $('#instruction_2').fadeIn(300);
        $('#webgazerVideoFeed').show();
      }
    });
  } else if  (direction == 'continue') {
    page++;
  } else if (direction == 'back') {
    page--;
  }
  page = page < 1 ? 1 : page;
  page = page > $('.instruction_page').length ? $('.instruction_page').length : page;
  page <= 1 ? $('#instruction_back').hide() : $('#instruction_back').show();
  page >= $('.instruction_page').length ? $('#instruction_continue').hide() : $('#instruction_continue').show();
  page >= 3 ? $('#instruction_back,#instruction_continue').hide() : "";
  block_no > 0 ? $('#instruction_back').hide() : "";

  if (oldpage != page) { // if we stay at the same page, we avoid unnecessary animations
    $('.instruction_page').hide();
    $('#instruction_'+page).fadeIn(300);
  }
  // start up webcam
  if (page == 2 && cam.initialized == 0) {
    $("#instruction_continue").hide();
    loadWebgazer();
  }
  oldpage = page;
}


var cl;
var t_start = new Date().getTime();
$('document').ready(function() {
  $('#stimulus').hide();
  $('#calibration_dot').hide();
  $('#setup_after').hide();
  $('#instruction_message').hide();
  $('#therest').hide();


  $('#start_button').click(function() {
    $(this).hide();
    prepareBlock();
  });

  $('body').keypress(function(e) {
    //e.preventDefault();
    switch(e.keyCode) {

    }
  });

  $('#instruction_continue').click(function() {
    navigation('continue');
  });

  $('#instruction_back').click(function() {
    navigation('back');
  });

  $( "#f_crowdflowerid" ).tooltip({
    show: {
      effect: "slideDown",
      delay: 250
    }
  });


  /*
  $('#f_birthday').datepicker({
      dateFormat: 'yy/mm/dd',
      changeYear: true,
      changeMonth: true,
      yearRange: "-100:+0"
  });
  */
  var select = $('#f_birthday');
  for (var i=18;i <= 100; i++){
    select.append('<option value="'+i+'">'+i+'</option>')
  }

  window.localStorage.clear();
   
  var ss = window.location.hash.substring(1);
  $('#cf_reference,#asd_reference,#rub_reference,#cf_code').hide();
  if (ss == "cf") { // crowdflower-reference
    $('#cf_reference,#cf_code').show();
  } else if (ss == "rub") {
    $('#rub_reference').show();
} else {
    $('#asd_reference').show();
}

  var is_chrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
  var is_firefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  if (is_chrome || is_firefox) {
    page = 0;
    navigation('start');
  } else {
    $('#instruction').hide();
    $('#message').html('Thank you very much for your interest in our Project.<br /><br />Unfortunately, your browser is not supported by our website. To participate, you need either the browser "Google Chrome" or "Firefox".<br /><br />Do download one of these securely and free of charge, please follow one of these links: <a href="https://www.google.com/chrome/browser/desktop/" target="_blank">Google Chrome</a> or <a href="https://www.mozilla.org/de/firefox/new/" target="_blank">Mozilla Firefox</a>').show();
  }
});


/**
 function drawLoop() {
    requestAnimFrame(drawLoop);
    var p = webgazer.getCurrentPrediction();
    if (p !== null) {
        console.log(p);
        $('body').append('<span class="p" style="top: '+p.y+'px; left: '+p.x+'px"></span>');
        measurements++;
    }
    t = (new Date().getTime() - start)/1000;
    cam.overlay.getContext('2d').clearRect(0,0,cam.width,cam.height);
    if (cl.getCurrentPosition()) {
        //console.log(cl.getCurrentPosition()[0]);
        //cl.draw(overlay);
    }
}
 */






window.onbeforeunload = function() {
  //webgazer.end(); //Uncomment if you want to save the data even if you reload the page.
}
</script>